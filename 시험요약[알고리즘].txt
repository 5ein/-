알고리즘 – 어떤 문제를 풀기위한 절차 공식적으로 표현
정렬 – 가장 느린 것(버블정렬), 가장 빠른 것(퀵정렬)
	버블정렬, 선택정렬, 퀵정렬 등등
빅오표기법 – 성능 표현법(방법의 성능을 평가할 때 사용), 가장 최악일 때를 기준으로 표현
String – length(), (length는 배열일 때 사용하는것임)
	equals(): 값을 비교할 때
	s = “hong”, s2 = “kim”
	s.substring(1) //ong (s[1] 이후로 다 프린트)
	s.indexOf(“h”) //0 (인덱스 어디인지 알아보기)
	String은 값이 변경되면 새로운 공간을 만듦(원래의 저장공간을 사용X)
		원래저장공간 사용하려면 StringBuilder 사용
	자주 변경되는 경우, String을 쓰면 메모리 관리에 비효율적이다.
	String은 값의 변경이 적은 경우 사용하면 효율적이다.
순서도 – 직사각형(처리), 다이아몬드(조건, 분기 => true/false), 종이 찢어진 사각형(출력)
Stack – 값을 저장공간에 넣는 것(push), 꺼내는것 (pop)
	맨 위(top), 맨 아래(bottom)
	Push를 하면, top이 하나 증가한다.
	top은 윗부분을 나타낸다.
	꺼낼 때는 top에서 먼저 꺼낸다.
	일주일치 책을 쭉 쌓아놓고, 위에서부터 읽어서 없앤다.
정렬 알고리즘 – 오름차순:(1, 2, 3, 4), 내림차순:(4, 3, 2, 1)
		버블, 선택, 퀵 빅오로 표현 최악의 상황 ==> O()
퀵 정렬 – 기준값(피벗) 1, 3, 9, 7, 5 정렬할때 ==> 1, 3, 5(피벗), 7, 9
	    피벗은 중간값을 사용함.
ArrayList<String> - String 데이터가 들어간 순서있는 데이터의 모음(String이외에는 넣을 수 없음)
		만약 ArrayList만 적는다면 – 기본타입은 Object을 설정한다.
시간복잡도 – cpu의 처리시간, 공간복잡도 – ram의 사용량
자료구조 – 중복X, 순서가 없는 데이터 구조(set)
큐(대기줄) – FIFO(선입선출구조, 먼저 들어온 것이 먼저 나간다.)
	         큐의 앞부분(front), 뒷부분(back, rear)
	         큐의 삭제는 front에서 이루어진다.
List – LinkedList, ArrayList, 순서O, 인덱스로 접근, FIFO(X), FILO(x),
HashMap – 키 + 값, JSON과 유사한형태, 키(유일O, 중복X), 값(중복O)
